<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AsynchronousuploadLong" xml:space="preserve">
    <value>By supplying this option, Duplicati will transmit files, while building volumes. This can shorten the time it takes to perform a backup, but requires more diskspace.</value>
  </data>
  <data name="AsynchronousuploadShort" xml:space="preserve">
    <value>Transmit files on a seperate thread</value>
  </data>
  <data name="AutocleanupLong" xml:space="preserve">
    <value>If a backup is interrupted there will likely be partial files present on the backend. Using this flag, Duplicati will automatically remove such files when encountered.</value>
  </data>
  <data name="AutocleanupShort" xml:space="preserve">
    <value>A flag indiciating that Duplicati should remove unused files</value>
  </data>
  <data name="BackupprefixLong" xml:space="preserve">
    <value>Any string used to prefix the filenames generated by Duplicati.</value>
  </data>
  <data name="BackupprefixShort" xml:space="preserve">
    <value>Backup volume filename prefix</value>
  </data>
  <data name="DisablefiletimecheckLong" xml:space="preserve">
    <value>The operating system keeps track of the last time a file was written. Using this information, Duplicati can quickly determine if the file has been modified. If some application deliberately modifies this information, Duplicati won't work correctly unless this flag is set.</value>
  </data>
  <data name="DisablefiletimecheckShort" xml:space="preserve">
    <value>Disable checks based on file time</value>
  </data>
  <data name="ExcludeLong" xml:space="preserve">
    <value>Exclude files that match this filter. The filter is a "file-globbing" filter, much like commandline options. You can use "*.txt" to exclude all text files.</value>
  </data>
  <data name="ExcluderegexpLong" xml:space="preserve">
    <value>Exclude files that match this filter. The filter is a regular expression filter. You can use "(.*)\.txt" to exclude all text files.</value>
  </data>
  <data name="ExcluderegexpShort" xml:space="preserve">
    <value>Exclude files regular expression</value>
  </data>
  <data name="ExcludeShort" xml:space="preserve">
    <value>Exclude files</value>
  </data>
  <data name="FiletorestoreLong" xml:space="preserve">
    <value>By default, duplicati will restore all files in the backup. Use this option to restore only a subset of the files</value>
  </data>
  <data name="FiletorestoreShort" xml:space="preserve">
    <value>A list of files to restore</value>
  </data>
  <data name="ForceLong" xml:space="preserve">
    <value>When deleting old files, Duplicati will only write out what files are supposed to be deleted. Specify the "force" option to actually remove them.</value>
  </data>
  <data name="ForceShort" xml:space="preserve">
    <value>Force the removal of files</value>
  </data>
  <data name="FullifolderthanLong" xml:space="preserve">
    <value>If the last full backup is older than the duration supplied here, Duplicati will make a full backup, otherwise an incremental</value>
  </data>
  <data name="FullifolderthanShort" xml:space="preserve">
    <value>The max duration between full backups</value>
  </data>
  <data name="FullLong" xml:space="preserve">
    <value>When this flag is specified, Duplicati will make a full backup of all files, and ignore any incremental data.</value>
  </data>
  <data name="FullShort" xml:space="preserve">
    <value>A flag used to force full backups</value>
  </data>
  <data name="GpgencryptionLong" xml:space="preserve">
    <value>By default, Duplicati will use the AES encryption algorithm to encrypt the backup volumes, setting this flag makes Duplicati use the GNU Privacy Guard instead. GnuPG must be installed on the machine for this to work.</value>
  </data>
  <data name="GpgencryptionShort" xml:space="preserve">
    <value>Use GnuPG for encryption</value>
  </data>
  <data name="GpgprogrampathLong" xml:space="preserve">
    <value>The path to the GNU Privacy Guard program. If not supplied, Duplicati will assume that the program "gpg" is avalible in the system path.</value>
  </data>
  <data name="GpgprogrampathShort" xml:space="preserve">
    <value>The path to GnuPG</value>
  </data>
  <data name="IncludeLong" xml:space="preserve">
    <value>Include files that match this filter. The filter is a "file-globbing" filter, much like commandline options. You can use "*.txt" to include all text files.</value>
  </data>
  <data name="IncluderegexpLong" xml:space="preserve">
    <value>Include files that match this filter. The filter is a regular expression filter. You can use "(.*)\.txt" to include all text files.</value>
  </data>
  <data name="IncluderegexpShort" xml:space="preserve">
    <value>Include files regular expression</value>
  </data>
  <data name="IncludeShort" xml:space="preserve">
    <value>Include files</value>
  </data>
  <data name="MaxdownloadprsecondLong" xml:space="preserve">
    <value>By setting this value you can limit how much bandwidth Duplicati consumes for downloads. Setting this limit can make the backups take longer, but will make Duplicati less intrusive.</value>
  </data>
  <data name="MaxdownloadprsecondShort" xml:space="preserve">
    <value>Max number of bytes to download pr. second</value>
  </data>
  <data name="MaxuploadprsecondLong" xml:space="preserve">
    <value>By setting this value you can limit how much bandwidth Duplicati consumes for uploads. Setting this limit can make the backups take longer, but will make Duplicati less intrusive.</value>
  </data>
  <data name="MaxuploadprsecondShort" xml:space="preserve">
    <value>Max number of bytes to upload pr. second</value>
  </data>
  <data name="NoencryptionLong" xml:space="preserve">
    <value>If you store the backups on a local disk, and prefer that they are kept unencrypted, you can turn of encryption completely by using this switch.</value>
  </data>
  <data name="NoencryptionShort" xml:space="preserve">
    <value>Disable encryption</value>
  </data>
  <data name="NumberofretriesLong" xml:space="preserve">
    <value>If an upload or download fails, Duplicati will retry a number of times before failing. Use this to handle unstable network connections better.</value>
  </data>
  <data name="NumberofretriesShort" xml:space="preserve">
    <value>Number of times to retry a failed transmission</value>
  </data>
  <data name="PassphraseLong" xml:space="preserve">
    <value>Supply a passphrase that Duplicati will use to encrypt the backup volumes, making the unreadable without the passphrase.</value>
  </data>
  <data name="PassphraseShort" xml:space="preserve">
    <value>Passphrase used to encrypt backups</value>
  </data>
  <data name="RestoretimeLong" xml:space="preserve">
    <value>By default, Duplicati will restore files from the most recent backup, use this option to select another item. You may use relative times, like "-2M" for a backup from two months ago.</value>
  </data>
  <data name="RestoretimeShort" xml:space="preserve">
    <value>The time to restore files</value>
  </data>
  <data name="RetrydelayLong" xml:space="preserve">
    <value>After a failed transmission, Duplicati will wait a short period before attempting again. This is usefull if the network drops out occasionally during transmissions.</value>
  </data>
  <data name="RetrydelayShort" xml:space="preserve">
    <value>Time to wait between retries</value>
  </data>
  <data name="ShortfilenamesLong" xml:space="preserve">
    <value>If the filesystem does not support the long filenames that Duplicati uses, this switch will change the time to be a much more compact, but hard to read format. It will also make the default prefix "dpl".</value>
  </data>
  <data name="ShortfilenamesShort" xml:space="preserve">
    <value>Use short filenames</value>
  </data>
  <data name="SignaturecachepathLong" xml:space="preserve">
    <value>If this path is supplied, Duplicati will store all signature files here, so re-downloads can be avoided.</value>
  </data>
  <data name="SignaturecachepathShort" xml:space="preserve">
    <value>A path to temporary storage</value>
  </data>
  <data name="SignaturecontrolfilesLong" xml:space="preserve">
    <value>Supply a list of files seperated with semicolons, that will be added to each backup. The Duplicati GUI program uses this to store the setup database with each backup.</value>
  </data>
  <data name="SignaturecontrolfilesShort" xml:space="preserve">
    <value>A list of control files to embed in the backups</value>
  </data>
  <data name="SignkeyLong" xml:space="preserve">
    <value>The GNU Privacy Guard can optionally sign volumes with a special key. This feature is not currently active in Duplicati.</value>
  </data>
  <data name="SignkeyShort" xml:space="preserve">
    <value>Sign key for GnuPG</value>
  </data>
  <data name="SkipfilehashchecksLong" xml:space="preserve">
    <value>If the hash for the volume does not match, Duplicati will refuse to use the backup. Supply this flag to allow Duplicati to proceed anyway.</value>
  </data>
  <data name="SkipfilehashchecksShort" xml:space="preserve">
    <value>Set this flag to skip hash checks</value>
  </data>
  <data name="SkipfileslargerthanLong" xml:space="preserve">
    <value>This option allows you to exclude files that are larger than the given value. Use this to prevent backups becoming extremely large.</value>
  </data>
  <data name="SkipfileslargerthanShort" xml:space="preserve">
    <value>A size string that limits the size of files being backed up</value>
  </data>
  <data name="TempdirLong" xml:space="preserve">
    <value>Duplicati will use the system default temporary folder. This option can be used to supply an alternative folder for temporary storage.</value>
  </data>
  <data name="TempdirShort" xml:space="preserve">
    <value>Temporary storage folder</value>
  </data>
  <data name="ThreadpriorityLong" xml:space="preserve">
    <value>Selects another thread priority for the process. Use this to set Duplicati to be more or less CPU intensive.</value>
  </data>
  <data name="ThreadpriorityShort" xml:space="preserve">
    <value>Thread priority</value>
  </data>
  <data name="TimeseparatorLong" xml:space="preserve">
    <value>Per default, Duplicati will use the colon ":" character to seperate the time fields in the filename. However, on some filesystem, notably windows, this character is not allowed. Use this option to use another character.</value>
  </data>
  <data name="TimeseparatorShort" xml:space="preserve">
    <value>Backup volume filename timeseperator</value>
  </data>
  <data name="TotalsizeLong" xml:space="preserve">
    <value>This option can place an upper limit on the total size of each backup. Note that if this flag is specified the backup may not contain all files, even for a full backup.</value>
  </data>
  <data name="TotalsizeShort" xml:space="preserve">
    <value>The number of bytes generated by each backup run</value>
  </data>
  <data name="VolsizeLong" xml:space="preserve">
    <value>This option can change the default volume size. Changing the size can be usefull if the backend has a limit on the size of each individual file</value>
  </data>
  <data name="VolsizeShort" xml:space="preserve">
    <value>A size string that limits the size of the volumes</value>
  </data>
  <data name="DisableStreamingLong" xml:space="preserve">
    <value>Enabling this option will disallow usage of the streaming interface, which means that transfer progress bars will not show, and bandwidth throttle settings will be ignored.</value>
  </data>
  <data name="DisableStreamingShort" xml:space="preserve">
    <value>Disables use of the streaming transfer method</value>
  </data>
  <data name="AllowfullremoveLong" xml:space="preserve">
    <value>As a precaution, the last full backup will never be removed, even if using the --remove-all-but-n-full=0 option. Set this option to allow removing the last backup.</value>
  </data>
  <data name="AllowfullremoveShort" xml:space="preserve">
    <value>Allow removal of the all backups</value>
  </data>
  <data name="DontreadmanifestsLong" xml:space="preserve">
    <value>This option will make sure the contents of the manifest file are not read. This also implies that file hashes are not checked either. Use only for disaster recovery.</value>
  </data>
  <data name="DontreadmanifestsShort" xml:space="preserve">
    <value>An option that prevents verifying the manifests</value>
  </data>
  <data name="AllowsourcefolderchangeLong" xml:space="preserve">
    <value>This option can be used to disable the check for the same source folders. It is used in unittests, and is NOT intended for everyday use. Do not use this option unless you know what you are doing.</value>
  </data>
  <data name="AllowsourcefolderchangeShort" xml:space="preserve">
    <value>Skip verifying the source folders</value>
  </data>
  <data name="FullifsourcefolderchangedLong" xml:space="preserve">
    <value>It is not allowed to change the sourcefolder or the number of source folders. If this option is enabled, the backup will become a full backup if the source folders have changed, which will then start a new chain of backups with the new folder set. If --allow-sourcefolder-change is also set, a full backup is only issued if the number of of source folders have changed</value>
  </data>
  <data name="FullifsourcefolderchangedShort" xml:space="preserve">
    <value>Run a full backup if the sourcefolder has changed</value>
  </data>
</root>